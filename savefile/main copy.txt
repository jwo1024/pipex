#include	"main.h"

#include	<stdio.h>
#include	<unistd.h> // execve
#include	<stdlib.h>
#include	<fcntl.h>

//int	pipex(char *envp[]);
//int	pipe(char *envp[]);

typedef struct s_info_pipex
{
	int		argc;
	char	**argv;
	char	**envp;
	char	*file1;
	char	*file2;

	char	*cmd_which_path;
	char	**splited_current_cmd;
	char	*current_cmd_path;

	int		min_cmd_index_argv;
	int		max_cmd_index_argv;

} t_info_pipex;


char	*which_cmd(char *cmd, char *envp[]);
int		is_valid_files(char *file1, char *file2);
int		pipex(t_info_pipex *info);
void	remove_linefeed(char **str);

int	main(int argc, char *argv[], char *envp[])
{
	char	**split_cmd;
	char	*cmd_path;
	t_info_pipex	info;
	// execve path 얻기 // which cmd 로도 찾을 수 있음 (무엇이 더 좋은가?)

	if (argc >= 5) //
	{
		// 유효한 인자인지 검사하기.. cmd는 실행 경로 찾으면서 검사하고, cmd 옵션은 오류 그대로 실행하는거 맞나 확인해주기
		if (!is_valid_files(argv[1], argv[argc - 1]))
			printf("may be invalid file\n"); // 에러처리
		
		// set_basic_info()
		info.argc = argc;
		info.argv = argv;
		info.envp = envp;
		info.file1 = argv[1];
		info.file2 = argv[argc - 1];

		pipex(&info);

		free(cmd_path);
	}
	// argv cmd 파싱
	// argv[2] = file1, argv[argc-1] = file2;
	// argv[3 ~ argc-2] = cmd

	// file 유효성 검사
	// pipex()

//	system("leaks a.out");
	return (0);
}

int	pipex(t_info_pipex *info)
{
	// ~여기서 분기 나누고 지지고 볶고 하기~
	// 분기 나누고 자식 프로세스 진행 함수, 부모프로세스 진행함수 나눠서 작성하면 코드가 쪼오끔 짧아지겟죠? 

	int	pipe1_fd[2];
	int	pipe2_fd[2];
	int	i;
	int	pid;
	int	status;
	int	file1_fd;
	int	file2_fd;


	pipe(pipe1_fd); // cmd 짝수일때
	printf("pipe1 fd %d %p// %d %p\n", pipe1_fd[0], &pipe1_fd[0], pipe1_fd[1], &pipe1_fd[1]);
//	pipe(pipe2_fd); // cmd 홀수일때
//	기존 파일을 입력으로 수정하기
//	close(1);
//	dup2(pipe1_fd[1], 1);
	printf("ABAA\n");

//	dup2(0, pipe1_fd[0]);


	i = 2;
	while (i < info->argc - 1)
	{
	
		pid = fork();
		//fork 실패시 오류

		if (pid == -1)
		{
			// fork 에러 처리
			printf("fail fork\n");
		}
		else if (pid == 0) // 자식 프로세스 일때
		{
		//	close(pipe1_fd[0]); // 안 해줘도 프로세스 종료시 자동으로 없어지지 않나? 
			printf("AAA\n");
			// dup 를 잘 해보자 !

			// 첫번째 일 경우 
			if (i == 2)
			{
				file1_fd = open(info->file1, O_RDWR);
				dup2(file1_fd, 0); // file -> 입력으로 친다.
				dup2(pipe1_fd[1], 1);
			}
			// 마지막일 경우 
			else if (i == info->argc - 2)
			{
				file2_fd = open(info->file2, O_RDWR);
				dup2(pipe1_fd[0], 0);
				dup2(file2_fd, 1);
			}
			// cmd 와 cmd 일 경우
			else
			{
				dup2(pipe1_fd[0], 0);
			}
	
			info->splited_current_cmd = ft_split(info->argv[i], ' ');
			info->current_cmd_path = which_cmd(info->splited_current_cmd[0], info->envp);
			if (info->current_cmd_path == NULL)
				; /// 유효하지 않은 입력이라는 뜻이다. 에러처리하기

			if (!execve(info->current_cmd_path, info->splited_current_cmd, info->envp))
				perror("execve fail... \n");
				// fail시 종료 설정을 따로 해주어야 하나? (close(fd) 및 return 이나 exit 으로 해주어야 하나?)
		}
		else // 부모 프로세스 일때
		{
			printf("parent proccess");
			/*
			for (int i = 0; info->splited_current_cmd[i]; i++)
				free(info->splited_current_cmd[i]);
			free(info->splited_current_cmd);
			*/
		}
		i++;
	}

	wait(&status);
	getchar();
//	close(file1_fd);
	
	return (1);
}

// cmd 경로를 가져오는 함수. 
// which 파일은 항상 같은 곳에 위치하고 있는가 ? envp 사용해서 which 찾기 // 변수로 which_path 넣기
char	*which_cmd(char *cmd, char *envp[]) 
{
	int		wait_pid;
	char	**argv_cmd;
	pid_t	pid;
	int		fd[2];
	int		status;
	char	*cmd_path;

	argv_cmd = (char **)malloc(sizeof(char *) * 3);
	argv_cmd[0] = ft_strdup("which");
	argv_cmd[1] = cmd;
	argv_cmd[2] = NULL;


	pipe(fd); // pipe의 버퍼 크기는 ? 
	pid = fork(); 
	// fork 실패시 별도 에러 처리 필요

	if (pid == 0) // 자식 프로세스일 경우에
	{
		dup2(fd[1], 1);
		if (!execve("/usr/bin/which", argv_cmd, envp))
			perror("execve fail... \n");
		// perror 어떻게 돌아가는지 알필요가 있어
	}



	wait_pid = wait(&status); //wait_pid 로 변경 필요
	free(argv_cmd[0]);
	free(argv_cmd);
	close(fd[1]);
	if (status == 0) // 정상종료시 0 // status의 값과 $? 에대해서 알 필요가 있어
	{
		cmd_path = get_next_line(fd[0]);
		remove_linefeed(&cmd_path);
		close(fd[0]);
		return (cmd_path);
	}
	else
	{
		close(fd[1]);
		close(fd[0]);
		return (NULL);
	}


	return (NULL);
}




/* utils */

int	is_valid_files(char *file1, char *file2)
{
	// 둘다 존재하는 파일이어야 하는건가?????? file2는 없다면 새로 만들어야 하나? ㅇㅇ 새로 만들어야함
	//  -> 그렇다면 자동적으로 만들어지나요? ? ? ? ? ? 아니요 그럼 어떻게 하죠 ? 

	if (access(file1, R_OK) == 0)
		return (1);
	else if (access(file2, F_OK) != 0 || access(file2, W_OK) == 0) // 아예 없는 파일이거나, 쓰기 가능한 파일이거나
		return (1);
	return (0);
}

void	remove_linefeed(char **str)
{
	int	len;
	
	len = ft_strlen(*str);
//	printf("----\n len %d %d\n", len, (*str)[len - 1]);
	if ((*str)[len - 1] == '\n')
		(*str)[len - 1] = '\0';
}





/*
	// 에러 처리 ? 
	//while((((waitPid = wait(&status)) == -1) && errno == EINTR));
	// interrupted system call 오류가 발생하더라도 wait 함수르 ㄹ재실행 할 수 잇어얗 ㅏㄴ다.
	if (WIFEXITED(status)) // 비정상 종료시  처리를 해주어ㅑ 하나 ? ? ? ? ? ?? 
	{
		printf("정상 종료 \n", WEXITSTATUS(status));
	}
	else if (WIFSIGNALED(status))
	{
		printf("비정상 종료 %d \n", WTERMSIG(status));
	}
*/

/*

int	pipe(char *envp[])
{

//	if (!execve(const char *path, char *const argv[], envp))
//	{

//	}
	return (0);
}

// file1을 표준 입력으로 만든다.
// cmd로 file1(표준입력)으로 입력을 받고, 

int	pipex(char *envp[])
{
	int	fd[2];
	int	file_fd;

	// fd = file1 열기

	while (0) // cmd count 
	{
		// fd 닫기
		// 새 pipe 만들기
		pipe(fd);


	//	fork -> cmd용 자식 프로세스

		dup2(1, fd[1]);
	//	dup 표준 출력을 pipe입력으로
	//	dup 표준 입력을 pipe출력으로 

	//	if (pid >= 0 cmd 자식프로세스일때)
	//	{
			// 해당 cmd의 argv 설정
	//		if (!execve(cons char *path, char *const argv[], envp))

			// cmd 가 유효하지 않으면 ? 
	//	}
	//	else if(pid = 0 부모 프로레스일때)


	//	pipe 닫기
	}

	//	wait 자식 프로세스 모두 종료될때까지
	// 오류로 (ex 입력이 필요한 프로세스에 입력이 없을때, 프로세스가 종료하지 않는다면 어떻게 처리를 해주어야 하는가?)
	// file2 에 저장

	return (0);
}

*/


/*
while (*envp)
	{
		printf("%s\n", *envp);
		(envp)++;
	}
	return (0);
*/