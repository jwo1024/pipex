#include	"main.h"

#include	<stdio.h>
#include	<unistd.h> // execve
#include	<stdlib.h>
#include	<fcntl.h>

typedef struct s_info_pipex
{
	int		argc;
	char	**argv;
	char	**envp;
	char	*file1;
	char	*file2;

} t_info_pipex;
// fork malloc free
typedef struct s_info_which
{
	char	*which_cmd[3];
	int		pipe_fd[2];
} t_info_which;


char	*which_cmd(char *cmd, char *envp[], t_info_which *which);
t_info_which	*set_info_which(t_info_which *info);
void	clear_info_which(t_info_which *info);


int	execute(int fd[2], char *cmd_argv, char **envp, t_info_which *info_which);

int		is_valid_files(char *file1, char *file2);
int		pipex(t_info_pipex *info);
void	remove_linefeed(char **str);

void	child_process(char *argv, char **envp, t_info_which *info_which);
void	set_fd_dup(t_info_pipex *info, int pipe_fd[2], int i);



int	main(int argc, char *argv[], char *envp[])
{
	int		pid[2];
	int		fd[2];
	int		pipe_fd[2];
	int		status;
	t_info_which	info_which;

	if (argc >= 5) //
	{
		if (!is_valid_files(argv[1], argv[argc - 1]))
			printf("may be invalid file\n"); // 에러처리
		
		set_info_which(&info_which);
		pipe(pipe_fd);
	
		//
		fd[0] = open(argv[1], O_RDONLY);
		fd[1] = pipe_fd[1];
		pid[0] = execute(fd, argv[2], envp, &info_which);
		close(fd[0]);
		close(pipe_fd[1]);

	//	waitpid(pid[0], &status, 0);
	//	printf("catch pid %d\n", pid[0]);
	
		fd[1] = open(argv[argc - 1],  O_TRUNC | O_CREAT | O_RDWR, 0000644);
		fd[0] = pipe_fd[0];
		pid[1] = execute(fd, argv[argc - 2], envp, &info_which);
		close(fd[1]);
		close(pipe_fd[0]);
		close(pipe_fd[1]);

	//	waitpid(pid[1], &status, 0);
	//	printf("catch pid2 %d\n", pid[1]);
	/*	int	r;
		r = 0;
		while (r <= 0)
		{
			r = waitpid(0, &status, WNOHANG);
			printf("r %d\n", r);
			getchar();
		}
		printf("rr %d", r);
	*/
	//	while(wait(&status) > 0) ;
		int i = 0;
		printf("aaaa pid1 %d\n", pid[1]);
		getchar();
		while (i < 2)
		{

			printf("a");
			getchar();
			waitpid(pid[i], &status, 0);
			printf("b");
			i++;
		}

	//	waitpid(-1, &status, 0);
	//	waitpid(-1, &status, 0);

		printf("parent finsih\n");
		clear_info_which(&info_which);
	}


//	system("leaks a.out");
	return (0);
}

int	execute(int fd[2], char *cmd_argv, char **envp, t_info_which *info_which)
{
	int		pid;
	char	**cmd_splited;
	char	*cmd_path;

	pid = fork();
	if (pid == 0)
	{
		dup2(fd[0], 0);
		dup2(fd[1], 1);
		close(fd[0]);
		close(fd[1]);
		cmd_splited = ft_split(cmd_argv, ' '); //s c
		cmd_path = which_cmd(cmd_splited[0], envp, info_which);
		if(!execve(cmd_path, cmd_splited, envp))
			perror("execute() execve failed\n");
	}
	return (pid);
}

int	pipex(t_info_pipex *info)
{
	int	pipe_fd[2];
	int	i;
	int	pid1;
	int	pid2;
	int	status;
	t_info_which	info_which;
	char	*cmd_path;


	if (pipe(pipe_fd) == -1)
		; //error;
	set_info_which(&info_which); // 

	i = 2;
	while (i < info->argc - 1) // - 2 ? 
	{
		
		if (i == 2)
			pid1 = fork();
		else
			pid2 = fork();
		printf("pipex pid1 %d %d\n", pid1, i);
		printf("pipex pid2 %d %D\n", pid2, i);

		if (pid1 == -1)
			; // error;
		else if (pid1 == 0) // 자식 프로세스 일때
		{
			// execute

			// 실패시 ? 해주어야 하나?
			free(cmd_path);
			close(pipe_fd[0]);
			close(pipe_fd[1]);
		}
		printf("i %d pid1 %d\n", i, pid1);
		
		i++;
	}

	clear_info_which(&info_which); // 

	waitpid(pid1, &status, 0); // waitpid 로 변경 ? 
	waitpid(pid2, &status, 0); // waitpid 로 변경 ? 

//	wait(&status);

	close(pipe_fd[0]);
	close(pipe_fd[1]);

	return (pid1);
}


void	child_process(char *argv, char **envp, t_info_which *info_which)
{
	char	**cmd_splited;
	char	*cmd_path;

	cmd_splited = ft_split(argv, ' ');
	cmd_path = which_cmd(cmd_splited[0], envp, info_which);
	clear_info_which(info_which);
	printf("cmd_path %s %lu\n", cmd_path, sizeof(cmd_path)); // 이게 leak 일까
	if (cmd_splited == NULL)
		; // 이거 처리 해주어야 함? 
	if (cmd_path == NULL)
		; // error; 없는 경로
	if (!execve(cmd_path, cmd_splited, envp)) //grep hi 실행 안됨 어떻게 해야함? 
		perror("execve fail... \n"); // fail시 종료 설정을 따로 해주어야 하나? (close(fd) 및 return 이나 exit 으로 해주어야 하나?)
}

void	set_fd_dup(t_info_pipex *info, int pipe_fd[2], int i)
{
	int		file_fd;

	if (i == 2)
	{
	//	close(pipe_fd[0]);
		file_fd = open(info->file1, O_RDONLY);
		dup2(file_fd, 0); // file -> 입력으로 친다.
		dup2(pipe_fd[1], 1);
	}
	else if (i == info->argc - 2)
	{
	//	close(pipe_fd[1]);
		file_fd = open(info->file2, O_RDWR | O_CREAT | O_TRUNC, 0777); //file2 파일 지웟다가 다시 생성해야함 // O_CREATE 권한설정
		dup2(pipe_fd[0], 0);
		dup2(file_fd, 1);
	}
	else // cmd -> cmd 일때
		dup2(pipe_fd[0], 0);
}


/* utils? */

// cmd 경로를 가져오는 함수. 
// which 파일은 항상 같은 곳에 위치하고 있는가 ? envp 사용해서 which 찾기 // 변수로 which_path 넣기
char	*which_cmd(char *cmd, char *envp[], t_info_which *which) // const char cmd ?
{
	pid_t	pid;
	int		status;
	char	*cmd_path;

	which->which_cmd[1] = cmd;

	pid = fork();

	if (pid == -1)
		; // error;
	else if (pid == 0) // 자식 프로세스일 경우에
	{
		dup2(which->pipe_fd[1], 1);
		if (!execve("/usr/bin/which", which->which_cmd, envp))
			perror("execve fail... \n"); // error? 
	}
	// 부모 프로세스일 경우
//	wait(&status);
//	printf("which pid %d\n", pid);
	waitpid(pid, &status, 0); //wait_pid 로 변경 필요
//	printf("catch which pid\n");
	if (status == 0) // 정상종료시 0 // status의 값과 $? 에대해서 알 필요가 있어 // 조건 다시 생각
	{
		cmd_path = get_next_line(which->pipe_fd[0]);
		remove_linefeed(&cmd_path);
		return (cmd_path);
	}
	// 비정상 종료시 = 잘못된 cmd 라는 뜻
	return (NULL);
}

t_info_which	*set_info_which(t_info_which	*info) // info 에 등록하는게 더 좋을듯 1번째 만 바꿔서 하는게 더 좋을것같네
{
	pipe(info->pipe_fd);
	info->which_cmd[0] = ft_strdup("which");
	info->which_cmd[1] = NULL;
	info->which_cmd[2] = NULL;
	return (info);
}

void	clear_info_which(t_info_which *info)
{
	if (!info)
		return;
	free(info->which_cmd[0]);
	close(info->pipe_fd[0]);
	close(info->pipe_fd[1]);
}

/* utils */

int	is_valid_files(char *file1, char *file2)
{
	if (access(file1, R_OK) == 0)
		return (1);
	else if (access(file2, F_OK) != 0 || access(file2, W_OK) == 0) // 아예 없는 파일이거나, 쓰기 가능한 파일이거나
		return (1);
	return (0);
}

void	remove_linefeed(char **str)
{
	int	len;
	
	len = ft_strlen(*str);
	if ((*str)[len - 1] == '\n')
		(*str)[len - 1] = '\0';
}
